:gitplant: http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/lemfi/kest/main/

= RabbitMQ Steps

Two steps are available:

* publish a message on a queue ````publish rabbitmq message````
* read a message from a queue ````given message from rabbitmq queue````

== Read a message from rabbitMQ

This step comes as a parameterized function, the parameterized type is the expected return type for the message to read. +
Default return type is `ByteArray`

=== Parameters to provide on step

* queueName: String // mandatory
* messageTransformer: String // transformer from `ByteArray` to expected return type, mandatory if other than `ByteArray`

* protocol: String // optional, amqp or amqps, defaults to amqp
* host: String // optional, defaults to localhost
* port: String // optional, defaults to 5672
* vhost: String // optional, defaults to /
* user: String // optional, defaults to guest
* password: String // optional, defaults to guest

protocol / host / port / vhost / user / password can be set globally on kest configuration file:
[source, yml, title=kest.yml]
----
rabbitmq:
  host: localhost
  port: 5672
  user: guest
  password: guest
  vhost: /
----

=== Sample
[source,kotlin]
----
`given message from rabbitmq queue`<String> {
        queueName = "kest"
        messageTransformer = { toString(Charsets.UTF_8) }
    }
----

N.B: For messages with Json format you may use `toJson` function, which maps `ByteArray` to a `JsonMap`. +
See link:../json/README.adoc[Kest JSON] documentation for more details.

== Publish a message on RabbitMQ

=== Parameters to provide on step

* message: String // mandatory, message to publish
* routingKey: String // mandatory,
* exchange: String // optional, defaults to "" (routing key has to be queue name)

* protocol: String // optional, amqp or amqps, defaults to amqp
* host: String // optional, defaults to localhost
* port: String // optional, defaults to 5672
* vhost: String // optional, defaults to /
* user: String // optional, defaults to guest
* password: String // optional, defaults to guest
* timeout: String // time in milliseconds to wait before message is assumed consumed, defaults to 2000

protocol / host / port / vhost / user / password / timeout / exchange can be set globally on kest configuration file:
[source, yml, title=kest.yml]
----
rabbitmq:
  host: localhost
  port: 5672
  user: guest
  password: guest
  vhost: /
  exchange:
  timeout: 2000
----

=== Sample
[source,kotlin]
----
`publish rabbitmq message` {
            message = """
            {
                "hello": "world"
            }
            """
            routingKey = "universe"
        }
----

=== Message consumed listener

Waiting for a certain time and assume that message will have be processed by backend can be a source of problems: +
too short, message wouldn't be consumed, too long, running scenarios might take too much time.

Kest provides a way to make step synchronous with message consumption on backend side. +
It comes with a proxy server that listens for events on RabbitMQ. +
You just have to connect your backend to this proxy server instead of RabbitMQ, and job is done: your steps are synchronous with messages consumption on backend.

[source,yaml,title="Configuration for Rabbit Proxy Server"]
----
rabbitmq:
  consumedMessageListener:
    active: true
----