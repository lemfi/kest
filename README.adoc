= Kest image:doc/modules/ROOT/images/tinylogo.svg[alt=Kest, 55]
:toc:
:preface-title: Overview

:includedir: ROOT/pages
:documentation: doc/modules/ROOT/pages/

:leveloffset: +1


:gitplant: http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/lemfi/kest/main/
:title-logo-image: image:doc/logo.svg[]

= Overview

== Presentation

Kest is a framework written in Kotlin for testing your backends. +
It relies on JUnit5 to run scenarios.

Easy to use, easy to extend.

It was created to meet the need to test backends and to interact with the middlewares on which they are based in a very simple way, in order to be able to concentrate on the functional to be tested by avoiding difficulty or heaviness brought about by interactions with multiple components.

====
Use case :

My backend consumes messages in a RabbitMQ queue, it exposes its data over HTTP, HTTP access is protected.
To test the behavior of my backend I will have to:

. post messages in RabbitMQ
. provision users in my mongo database
. make HTTP requests to my backend

&#8658;
I'm going to need to interact with three different technologies, with different clients to handle. +
&#8658; Kest allows you to get away from it all +
&#8658; Kest is an engine that will play scenarios, scenarios will be a sequence of steps +
&#8658; Kest provides ready-made steps to interact with HTTP, RabbitMQ, MongoDB, Redis, and Cadence +
&#8658; Kest allows you to define your own steps: you use a techno not supported by Kest? design your steps! +
====

:gitplant: http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/lemfi/kest/main/
:title-logo-image: image:doc/logo.svg[]

== Use it

=== Gradle

[source,kotlin]
----
    implementation("com.github.lemfi.kest:core:0.7.1")
    implementation("com.github.lemfi.kest:junit5:0.7.1")

    // include the steps you need among available ones
    implementation("com.github.lemfi.kest:step-http:0.7.1")
    implementation("com.github.lemfi.kest:step-cadence:0.7.1")
    implementation("com.github.lemfi.kest:step-mongodb:0.7.1")
    implementation("com.github.lemfi.kest:step-rabbitmq:0.7.1")
    implementation("com.github.lemfi.kest:step-redis:0.7.1")

    // toolbox for Json Data
    implementation("com.github.lemfi.kest:json:0.7.1")

----

=== Maven

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>com.github.lemfi.kest</groupId>
        <artifactId>core</artifactId>
        <version>0.7.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.github.lemfi.kest</groupId>
        <artifactId>junit5</artifactId>
        <version>0.7.1</version>
        <scope>test</scope>
    </dependency>

    <!-- include the steps you need among available ones -->
    <dependency>
        <groupId>com.github.lemfi.kest</groupId>
        <artifactId>step-http</artifactId>
        <version>0.7.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.github.lemfi.kest</groupId>
        <artifactId>step-rabbitmq</artifactId>
        <version>0.7.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.github.lemfi.kest</groupId>
        <artifactId>step-cadence</artifactId>
        <version>0.7.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.github.lemfi.kest</groupId>
        <artifactId>step-mongodb</artifactId>
        <version>0.7.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.github.lemfi.kest</groupId>
        <artifactId>step-redis</artifactId>
        <version>0.7.1</version>
        <scope>test</scope>
    </dependency>

    <!-- toolbox for Json Data -->
    <dependency>
        <groupId>com.github.lemfi.kest</groupId>
        <artifactId>step-json</artifactId>
        <version>0.7.1</version>
        <scope>test</scope>
    </dependency>
</dependencies>
----

:gitplant: http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/lemfi/kest/main/
:title-logo-image: image:doc/logo.svg[]

== Big picture
=== Scenarios

Kest allows you to write scenarios. +
One scenario is a sequence of steps. +
One step defines an execution and a list of assertions to validate completed execution.

Let's take following example:

[source,kotlin]
----
scenario(name = "api says hello and remembers it!") {

    `given http call`<String> {

        url = "http://myapi/hello"
        method = "POST"
        headers["Authorization"] = "Basic aGVsbG86d29ybGQ="
        body = """
            {
                "who": "Darth Vader"
            }
        """
    } `assert that` { stepResult ->

        eq(201, stepResult.status)
        eq("Hello Darth Vader!", stepResult.body)
    }

    `given http call`<String> {

        url = "http://myapi/hello"
        method = "POST"
        headers["Authorization"] = "Basic aGVsbG86d29ybGQ="
        body = """
            {
                "who": "Han Solo"
            }
        """
    } `assert that` { stepResult ->

        eq(201, stepResult.status)
        eq("Hello Han Solo!", stepResult.body)
    }

    `given http call`<List<String>> {

        url = "http://myapi/hello"
        method = "GET"
        headers["Authorization"] = "Basic aGVsbG86d29ybGQ="

    } `assert that` { stepResult ->

        eq(200, stepResult.status)
        eq(listOf("Darth Vader", "Han Solo"), stepResult.body)
    }
}
----

This example defines a scenario with three steps:

. Say hello to Darth Vader
. Say hello to Han Solo
. Get list of people that were greeted

For each step 2 assertions are done:

. check status code
. check body

=== Run a scenario

To run a scenario Kest uses Junit5 engine:

. Create a class to hold your test
. Create a function annotated with Junit5 `@TestFactory`
. Make it call Kest function
.. `play scenarios` to play multiple scenarios in a single junit5 test factory +
=> in this case you can pass `beforeEach` and `afterEach` attributes representing a lambda returning a scenario to be played before and after each scenario if needed.
=> in this case you can pass `beforeEach` and `afterEach` attributes representing a lambda returning a scenario to be played before and after each scenario if needed.
.. `play scenario` to play one scenario per junit5 test factory +
=> in this case you can use junit5 annotations `@BeforeEach` and `@AfterEach`

[source,kotlin]
----

class TestHttpServer {

    @TestFactory
    fun `http server says hello`() = `play scenarios`(
            scenario { /*...*/ },
            scenario { /*...*/ },
            scenario { /*...*/ },

            beforeEach = { scenario { /*...*/ }},
            afterEach = { scenario { /*...*/ }}
    )


    @TestFactory
    fun `http server says goodbye`() = `play scenarios`(
            scenario { /*...*/ },
            scenario { /*...*/ },
            scenario { /*...*/ },

            beforeEach = { scenario { /*...*/ }},
            afterEach = { scenario { /*...*/ }}
    )

}

class TestHttpServer {

    @BeforeEach
    fun beforeEach() {
        /*...*/
    }

    @AfterEach
    fun afterEach() {
        /*...*/
    }

    @TestFactory
    fun `http server says hello - scenario 1`() = `play scenario`(
            scenario { /*...*/ }
    )

    @TestFactory
    fun `http server says hello - scenario 2`() = `play scenario`(
            scenario { /*...*/ }
    )

}
----

== Focus on how it works

image::{gitplant}/doc/diag/model.puml[]

When a scenario is launched, all its steps are launched sequentially, if one step fails the scenario fails without running remaining steps. +
When a step is launched its execution is played, then assertions are played against execution result. +
A step returns an object . which is invokable: you may reuse its result in another step . which you may complete by your own assertions, they will be added to assertions already defined on step

:leveloffset!:
:leveloffset: +1

:gitplant: http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/lemfi/kest/main/
:title-logo-image: image:doc/logo.svg[]

= Steps

A step is where interaction with your system happen, it:

* has a name
* can be retried
* has an execution
* has a list of assertions

[source,kotlin]
----
step(
    name = "a name a step has",
    retry = 10.times `by intervals of` 200.ms, // if assertions of step fail, step will be retried 10 times by intervals of 200 ms before really failing. Useful if you have asynchonous stuff going on on your backends.
) {
    // here goes the definition of the execution
} `assert that` {
    // here goes list of assertions
}
----

== Available Steps

=== xref:{documentation}steps/http.adoc[HTTP]
=== xref:{documentation}steps/rabbitmq.adoc[RabbitMQ]
=== xref:{documentation}steps/mongodb.adoc[Mongo]
=== Redis
=== Cadence

== Create your own step

You need custom steps not provided by Kest? Two options:

* Use generic step `step`
+
[source,kotlin]
----
step(name = "name of my step") {

    // execute your need here
    1+1

} `assert that` { stepResult ->

    eq(2, stepResult)

}
----
* xref:{documentation}steps/create-step.adoc[Create your own one]

:leveloffset!:
:leveloffset: +1

:gitplant: http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/lemfi/kest/main/

= JSON support

JSON is a common format to interact between machines, as matter of fact, Kest comes with advanced support to that format with a bunch of assertions. +
It also comes with two Objects: `JsonMap` and `JsonArray`

* `JsonMap` is a `Map<String, Any?>`
* `JsonArray` is an array of `JsonMap`

== Matchers

Kest provides several function to check whether a json content matches a Json pattern.
To do so, Kest provides by default 3 matchers:

* {\{string}}
* {\{number}}
* {\{boolean}}

For example

[source,json]
----
{
  "string": "a string",
  "number": 1,
  "boolean": true
}
----

is matched by

[source,json]
----
{
  "string": "{{string}}",
  "number": "{{number}}",
  "boolean": "{{boolean}}"
}
----

or by

[source,json]
----
{
  "string": "{{string}}",
  "number": 1,
  "boolean": "{{boolean}}"
}
----

And the function to check that with Kest would be:

[source,kotlin]
----
jsonMatches(
"""
{
  "string": "{{string}}",
  "number": "{{number}}",
  "boolean": "{{boolean}}"
}
""",
"""
{
  "string": "a string",
  "number": 1,
  "boolean": true
}""")

// OR shortcuts are provided two write it without having to remember the notation
jsonMatches(
"""
{
  "string": "$stringPattern",
  "number": "$numberPattern",
  "boolean": "$booleanPattern"
}
""",
"""
{
  "string": "a string",
  "number": 1,
  "boolean": true
}""")
----

=== Defining your own matchers

If you want to define your own matchers, several possibilities:

==== Define it textually

[source,kotlin]
----
val samplePattern = pattern("sample") definedBy """{
  "string": "$stringPattern",
  "number": "$numberPattern",
  "boolean": "$booleanPattern"
}"""
----

To check match you can now call this:

[source,kotlin]
----
jsonMatches(
"""
{{sample}}
""",
"""
{
  "string": "a string",
  "number": 1,
  "boolean": true
}""")

// OR

jsonMatches(
samplePattern.pattern,
"""
{
  "string": "a string",
  "number": 1,
  "boolean": true
}""")
----

==== Define a class

[source,kotlin]
----
data class Sample(
        val string: String,
        val number: Int,
        val boolean: Boolean
)
----

Then declare it as a pattern:

[source,kotlin]
----
val samplePattern = pattern("sample") definedBy Sample::class
----

To check match you can now call this:

[source,kotlin]
----
jsonMatches(
"""
{{sample}}
""",
"""
{
  "string": "a string",
  "number": 1,
  "boolean": true
}""")

// OR

jsonMatches(
samplePattern.pattern,
"""
{
  "string": "a string",
  "number": 1,
  "boolean": true
}""")
----

==== Define a function that will check the validity of pattern

[source,kotlin]
----
fun checkDateFormat(data: String): Boolean {
    val dateFormatter = DateTimeFormatter.ofPattern("YYYY-MM-dd").withResolverStyle(STRICT)

    return try {
        dateFormatter.parse(data)
        true
    } catch (e: DateTimeParseException) {
        false
    }
}
----

Then declare it as a pattern:

[source,kotlin]
----
val samplePattern = pattern("sample") definedBy ::checkDateFormat
----

To check match you can now call this:

[source,kotlin]
----
jsonMatches(
"""
{
  "date": "{{sample}}",
  "number": "$numberPattern",
  "boolean": "$booleanPattern"
}
""",
"""
{
  "date": "2021-01-12",
  "number": 1,
  "boolean": true
}""")

// OR

jsonMatches(
"""
{
  "date": "$samplePattern",
  "number": "$numberPattern",
  "boolean": "$booleanPattern"
}
""",
"""
{
  "date": "2021-01-12",
  "number": 1,
  "boolean": true
}""")
----

=== Lists and nullable matchers

==== Lists
What if you want to check that an array contains a list of objects validating a pattern?

[source,json]
----
{
  "data": [
    {
      "string": "a string",
      "number": 1,
      "boolean": true
    },
    {
      "string": "another string",
      "number": 2,
      "boolean": false
    }
  ]
}
----

[source,kotlin]
----
val samplePattern = pattern("sample") definedBy """{
  "string": "$stringPattern",
  "number": "$numberPattern",
  "boolean": "$booleanPattern"
}"""
----


To check match you can now call this:

[source,kotlin]
----
jsonMatches(
"""
{
  "data": "[[{{sample}}]]"
}
""",
"""
{
  "data": [
    {
      "string": "a string",
      "number": 1,
      "boolean": true
    },
    {
      "string": "another string",
      "number": 2,
      "boolean": false
    }
  ]
}""")

// OR

jsonMatches(
"""
{
  "data": "${jsonArrayOf(samplePattern)}",
  "number": "$numberPattern",
  "boolean": "$booleanPattern"
}
""",
"""
{
  "data": [
    {
      "string": "a string",
      "number": 1,
      "boolean": true
    },
    {
      "string": "another string",
      "number": 2,
      "boolean": false
    }
  ]
}""")
----

==== Nullable values

[source,kotlin]
----
val samplePattern = pattern("sample") definedBy """{
  "string": "${stringPattern.nullable}",
  "number": "$numberPattern",
  "boolean": "$booleanPattern"
}"""
----


To check match you can now call this:

[source,kotlin]
----
jsonMatches(
"""
{
  "string": "{{string?}}",
  "number": "$numberPattern",
  "boolean": "$booleanPattern"
}
""",
"""
{
      "string": null,
      "number": 1,
      "boolean": true
}""")

// OR

jsonMatches(
"""
{
  "string": "${stringPattern.nullable}",
  "number": "$numberPattern",
  "boolean": "$booleanPattern"
}
""",
"""
{
      "string": null,
      "number": 1,
      "boolean": true
}""")
----

== Polymorphism

To go through polyphormism, Kest allows you to define a list of matchers for a given JSON.

Let's take this example:

[source,json]
----
{
  "common":  "{{string}}",
  "poly1": "{{string}}"
}
----

[source,json]
----
{
  "common":  "{{string}}",
  "poly2": "{{string}}"
}

----

You can check whether your json matches one or the other of those matchers by passing a list to `jsonMatches` function:

[source,kotlin]
----
jsonMatches(
                listOf(
                """{
                      "common":  "{{string}}",
                      "poly1": "{{string}}"
                    }
                """,
                """{
                      "common":  "{{string}}",
                      "poly2": "{{string}}"
                    }
                """
                ),
                 """{
                      "common":  "a string",
                      "poly2": "another string"
                    }
                """
        )
----

== Lists

It works all the same for lists!

== Tips

For reading data easily from a JsonMap you may use function `JsonMap.getForPath(...)`
For exemple for a JsonMap representing that Json:
[source,json]
----
{
    "star": "wars",
    "characters": [
        { "luke": "skywalker" },
        { "han": "solo" },
        { "R2": "D2" }
    ]
}
----
You may use it like that:
[source,kotlin]
----
val jsonMap: JsonMap
val name1 = jsonMap.getForPath<String>("characters[0]", "luke") // == "skywalker"
val name2 = jsonMap.getForPath<String>("characters[1]", "han") // == "solo"
val name3 = jsonMap.getForPath<String>("characters[2]", "R2") // == "D2"
----

:leveloffset!:
:leveloffset: +1

= Gherkin support

Scenarios can be described in Gherkin and implemented with Kest. Documentation coming soon...

:leveloffset!:
:leveloffset: +1

= Configuration

You might want to access data from a configuration file. +
Kest configuration relies on https://github.com/sksamuel/hoplite +
You may add your entries in a file named kest.yaml which will be located at the root of your classpath +
All data from this file has to be mapped to a kotlin data class.

Then you can access your configuration by calling function `property`:

[source,yml,title=kest.yml]
----
mykey: myvalue
myotherkey: myothervalue

domain:
  akey: a value
  anotherkey: anothervalue
----

[source,kotlin,title="Configuration data class"]
----

data class Properties(
    val mykey: String,
    val myotherkey: String,
    val domain: Domain
)

data class Domain(
    val akey: String,
    val anotherkey: String
)
----

[source,kotlin,title="Access configuration"]
----
property(Properties::class) { myKey }
property(Properties::class) { myValue }
property(Properties::class) { domain.akey }
property(Properties::class) { domain.anotherkey }

// or with you may create your own shortcut:
fun <R> props(prop: Properties.() -> R) = property(Properties::class) { prop() }
// and then use it like that:
props { myKey }
props { myValue }
props { domain.akey }
props { domain.anotherkey }
----

== Change kest.yml location
If you need to set another location for Kest you can run tests with property `kest-conf` or environment variable `KEST_CONF` with the location you need

:leveloffset!:
